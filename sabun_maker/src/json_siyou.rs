
use json5_parser::JVal;
use crate::error::Result;

#[allow(dead_code)]
pub fn untyped_example() -> Result<JVal> {
    // Some JSON input data as a &str. Maybe this comes from the user.


    let data = r#"
{
  hogeNumber : 10,
  hogeString : "hoge",
  hogeBool : true,
  hogeObj : {
    hugaNumber : 30,
    "@HugaNumber" : 30, //先頭が大文字のメンバ名はすべてシステムが予約しているので認められない。しかしメンバ名をどうしても大文字で始めたい場合、
                        //jsonでは戦闘に@をつけ、プログラム側では@なしでもアクセス可能にするという技も使えなくはなかろうと思う。

    //名前が?で終わるメンバはnull値を含むことが出来る。
    //プログラム側のメンバ名にはこの?は反映されず、型が変わるだけ(もし俺以外の実装が現れたらわからないが・・・）
    //初期値にnullを入れるには、特殊な記法を使う必要がある
    "hegoNumber?" : ["Num", null], //型を指定し、null値を入れる。これでnullになる。

    //!で終わる場合、バージョン違いでこのメンバを持っていなかった場合、デフォルト値でなくundefinedが入る。
    //undefinedを代入する手段はない。
    "pugyaNumber!" : 10,
    "pugyaNumber2!?" : ["Num", null], //!?も出来る。?!でも良い。

    //配列はいまのところnumber配列、string配列、number配列の配列の4通り。
    numArray2 : [ "Num-Array", 0, 3, 10 ],
    //numArray3 : [ "Num-Array", [0, 3, 10] ], これはできない

    emptyNumArray : [ "Num-Array" ], //初期値が空配列のnum-array
    "nullableNumArray?" : [ "Num-Array", null ], //nullable配列の初期値をnullにする場合
    numArray2 : [ "Num-Array2", [2,3], [3,1] ], //二次元のnumarray


	strArray : [ "Str-Array", "hoge", "hogehoge" ], //文字列配列
	//そもそも配列なんてこのシステムに必要なんだろうか・・・？　まともに差分生成出来る気もしないしなあ。

	hogeList : [
		"List", //Listは配列とは違う。オブジェクトのコレクションを作るためにはlistを使う必要がある。
		["ListID", "hogehoge"], //任意でListIDを与えることが出来る。ListIDは全データの中で一意である必要がある。
		["Default", {
			hogeNumber : 0,
			hogeString : "hoge"
		}], //デフォルト値を設定。実際のリストには加わらない。
		{
			ID : "first",
			hogeNumber : 12,
			hogeString : "huga"
		},
		{
			ID : "second",
			//リストでは、デフォルト値から変更がない場合は書かなくても良いんじゃないかと思う
		}
	],

	"Rename" : [ "prevName->currentName",
	             "prevName2->currentName2" ], //メンバ名の変更をした場合、これを書いておくことで自動でメンバ名の対応表を作ってくれる。

	hogeList2 : [
	  "List",
	  ["Default", "second" ], //デフォルトのIDを指定。Defaultを指定しない場合最初のものがデフォルトになる。
	  {
	    ID : "first",
	    member1 : "hoge"
	  },
	  {
	    ID : "second",
	    member2 : "this_is_default", //これがデフォルト値となり、差分が取られる。
	  }
	],
  },

  usables : [
    "List",
    ["ListID", "usable"],
    {
      ID : "yakusou",
      num : 3
    },
    {
      ID : "dokukesisou",
      num : 31
    }
  ],

  weapons : [
    "List",
    ["ListID", "weapon"],
    {
      ID : "katana",
      atk : 5
    },
    {
      ID : "doutanuki",
      atk : 7
    }
  ],

  itemList : [
    "List",
    ["AutoID"],
    ["RefListID", "weapon"],
    {
      RefID : "doutanuki", //どうたぬきを参照。参照すると継承される。
      atk : 8 //overrideしてみる
    }
  ],

  hogeList : [
    "List",
    ["ListID", "hoge"],
    {
      ID : "hogehoge",
      mem : "a",
    }
  ],

  hugaList: [
    "List",
    ["ListID", "huga"],
    {
      ID : "hugahuga"
    }
  ],

  hegoList: [
    "List",
    ["ListID", "hego"],
    {
      ID : "hegohego",
      mem : "b",
    }
  ],

  itemList3 : [
    "List",
    ["AutoID"],
    ["RefListIDs",  //複数の参照が必要な場合、RefListIDsを設定する
      "hoge", "huga?", //nullableにも出来る
      //{hegoNew : "hego"} //名前を変更する機能を作るかは未定。idである以上いらなくないか？
    ],
    {
      RefIDs : { //RefListIDsが設定されている場合、RefIDsが必要。必要なメンバを設定する。
        hoge : "hogehoge", //RefListIDと、RefIDをセットで記述していく。
        //nullableは入力しなければデフォルトでnull
        hegoNew : "hegohego",
      },
      "memOverride?" : ["String"],
    }
  ],
  "nullableObj?" : {
    member1 : 31,
  }
}

//使用側 概念コード
//let item = itemList3[0]; //item は hogehoge と hegohego を参照している
//item.RefIDs.hoge.mem <これは"a"である
//item.hoge.mem <直接メンバとして呼び出すことも可能。同名のメンバがある場合はそちらが優先。
//list idは究極的なところ、一度作ったらもう二度と変えられないと思う。メンバ名は変えられるようになってるので、必要ならそっちを変えればよろしかろう。
//item.hoge.mem = "b" //参照越しに書き換えてもいいのか？　わからないけれど、システムレベルで禁止する必要はないだろう。必要なければ使わなければ良い。
//存在自体が害悪になるような機能ならライブラリ側で勝手に隠せば良い。
//個別にoverrideしたいケースがあるかもしれないが、override機能を実装するのはやはりおかしいと思うので（これはただのデータ記述システムであり、オブジェクト指向言語じゃない。
//nullableなメンバを上書きして、実質overrideのようにした方が良かろうと思う。
////item.memOverride = "c" //nullableなメンバを書き換える
//if(item.memOverride != null){ return item.memOverride } else{ return item.mem }


//Listのオブジェクトはデフォルト値からの差分が表現されているだけである。
//IDが必要である。他のパラメタはデフォルト値から変更がなければ必要がない。
//RefIDまたはRefIDsがListに設定されている場合は、メンバを作る必要があり、対応するオブジェクトまたはStringを設定する必要がある。
//ただ、ここのバージョン管理をどうするべきなのか全く不明である。RefIDの参照先が消えた場合、RefIDsのメンバ名が変更された場合、メンバがなくなった場合など。
//RefIDsに新メンバが追加された場合、参照先なし、nullの状態とすることで事なきを得ることが出来るだろう。メンバが削除された場合も、ないものにアクセスする人はいないから問題ない。
//list_idが変更される、これは面倒を見きれない。idが変更される、これもRenameのような追跡機能を作る価値はないように思う。
//根本的に、元jsonの仕様変更で参照先が消えてしまう、ということは当然起きるものとして、参照先はあればめっけもん、なくても問題ないようにプログラムを組むのが基本になると思う。
//そもそもlistからitemが削除されれば参照先はなくなってしまうので、参照先がなくならないことを前提にプログラムを組むべきではないように思う。まあ削除機能をなくして絶対に参照先がなくならないようにするのも手だとはおもうけれど、
//そのアプローチでは仕様変更には対応できず、仕様変更しないと頑なに誓っても変更は起きるものだろうと思う。
//参照先がid名の仕様変更でなくなってしまい、必要なデータが失われるようなら、古いバージョンのデータを使い回すのは諦めてもらうほかないだろう。
//デフォルトオブジェクトの変数の追加、これはデフォルト値が透過されるだけなので問題ないはず。
//変数の削除、削除したデータにアクセスする人はいないはずなので問題ないだろう。必要なら削除せず残しておくべき。どうせこのシステムは差分しか保存されないのだし。
//変数名の変更、これはまあやってもいいと思う。参照先IDとかではないので、パラメタになっていない以上管理可能だと思う。
//RefListIDsの変数の追加。これもデフォルトのnull、参照先なしが透過されるだけなので問題なかろう。
//RefListIDsの変数の削除、これも削除されたものにアクセスする人はいないので問題なかろう。
//RefListIDsの名前の変更、これはlist_idの変更にほかならない。
//list内オブジェクトでlist定義は出来ず、二重listは発生しない予定である。なのでlist_idはパラメタライズされていないと考えられる可能性もある。
//つまりlist_idはデータ全体で一意なので、ListIDのRename設定もデータ全体で一つのテーブルに管理させることで名前の変更も理論上可能と考えられる。
//問題はそこまでする価値はないだろうということ。なんでそこまでしてバージョン間でlist_idを変えながら動作させたいのか。
//list_idが変わった場合、「参照先なし」として動作してもらうことで、一応panicせずに動かすことは出来る。動いているうちに入るのかは謎だが・・・
//さらに、listごとにID名変更テーブルを設定可能にすることで、古い参照先を新しい参照先に対応させることも可能である。
//どっちにしても、参照先idが消える事態にはどうあがいても対応できないわけだが・・・やれるだけやるとしようか・・・？？？
//根本的に、参照先IDはパラメタライズされてるとは考えていない。実際勝手にIDを作ってlistに新規追加することは仕様上可能だけど、その使い方をバシバシしてくるとは思っていない。
//もっとデータは静的なものだと思う。ゲームでも薬草の新しいやつをゲーム中にプレイヤーが追加するよりも、製作者がアップデートで追加する方が普通だろう。
//しかし、キーでしかないただのIDを変更可能にする必要がどれだけあるのだろうか。可読性や意味を司るパラメータ名と違って、IDは他と区別するための記号という意味のほうが遥かに強いはずである。
//つまり、データが壊れるのが嫌なら被参照ListのIDは削除するな、変更するな、管理不能になるのが嫌なら追加も慎重にしろ、という掛け声だけで大半の問題は解決可能ではないかと思われる。
//list_idは可読性に関わるパラメータ名として立ち現れるので変更可能にすべきかも知れない。
//やはり、開発途中のデータと完成時のデータで、開発途中のデータが少しでも使えなくなる可能性がある変更は、完成時に整合性を持たせるために最終的に使わなかったものを削除していく、といった作業として現れてきて、
//「開発途中では作ってたけど最終バージョンではいらなかった」ものを一つ一つ判断するというおよそ不可能なことを行わなければならず、誤削除によって破綻してしまう可能性があるので、誤削除が起こりうるフォーマットはいずれ破綻すると思われる。
//誤削除が行われないようにするためには、削除を行う必要がないデータ形式にする必要があり、そのために「差分しか保存しない」使われず変化がないデータは保存されないので無視できるシステムになっていて、
//さらに使われなくなったidに関しても、削除でなくobsolete_hogeのようにIDを変更し脇に追いやることも可能になる。脇に追いやるのにID変更が必要なのかは必ずしも定かでないが・・・
//開発途中のどのバージョンのデータも、常に整合性をもって、管理可能な複雑度のまま最新バージョンで動かすことが出来る、というのでなければどうせ破綻するという考えに基づいて動くべきだと思う。
//そのためのプラクティスとして、「idの削除はしない」「id名、list_id名は変更可能なので、使わなくなったらobsolete_とかにして脇においやる」というのが良かろうと思う。
"#;

    // Parse the string of data into serde_json::Value.
    match json5_parser::from_str(data){
        Ok(v) =>{
            //println!("{}", serde_json::to_string_pretty(&v).unwrap());
            Ok(v)
        },
        Err(e) =>{ println!("{:?}", e); panic!(); },
    }

}