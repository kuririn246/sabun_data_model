まず初期値をjsonで記述する。俺はjson5を使う。そして初期ファイルからスキーマを取り出す。
共通のスキーマを持つ２つのデータからは差分を取得することが出来る。

schemaが変わっていても、単にメンバが追加されただけならデータの整合性の破綻はしないはずだ。
元schemaがバックアップされているなら、それを読み出して、現在のschemaとの対応関係を調べ、2番目のメンバ→3番目のメンバといった変換表を作り、
それに沿って読み出してしまえば、ユーザに意識させることなくメンバの追加は可能である。
メンバ名を変更するだけなら、対応表を書いておけば対応できる。
メンバを削除した場合データを反映させなくするだけなら自動でできるが、それで大丈夫なのか定かでない。
そのあたりは怪しいが、メンバの追加、デフォルト値、メンバ名の変更は自動で対応したい。
メンバの削除もまあ警告かなんか出したほうがいいかもしれないが、とりあえず出来るようにしよう。

値の定義の変更、それに伴う値の更新などは、やろうとすると非常に難しい。自動でできるようにするべきなのかわからない。
とりあえず、スキーマ変換時に定義がない場合の初期値と、通常の初期値を別で設定できるようにして、プログラム側では定義がない場合に新しく計算して値を入れる、という処理を書いてもらうのが良いのではないかと思う。


フォルダ構成はこのような感じ

RootFolder+
-Initial+
--initial.json //初期値のjson
--2019-11(Nov)-30-11h25m22s1536-hash128alphabets.json //差分生成に使用した初期jsonファイルはコピーして、タイムスタンプとハッシュ値も記録しておく。

//名前変更、値の変換などは変換表を手動で用意することで自動でやってくれるようにもしたいが、実用的に使うのはまあ難しい気がする。
//いちいち値の定義を変えたりしながら開発しつつ元データを使いまわそうとするなんて混乱の元だろう。変換に使う式を何の言語で書くのかというのも問題になる。
//多分JavaScriptになるがそのためにJavaScriptインタプリタに依存する価値があるだろうか。
//そのへんはよくわからないが、「名前の変更」に関しては変換表を使って対応できるようにしたい。

-1A //1Aフォルダ。１つ目のA差分なので1A
--1A-30-Nov-2019-8:36:31:8615-hash128alphabets.asabun //A差分。
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//1/10000のタイムスタンプと128bitハッシュで一意性を保証
                                                      //タイムスタンプは64bit整数で間に合う桁数ならなんでもいいが可読性も大事だろうから小数点以下4桁まででいいのでは
--1B //B差分フォルダ
---1B-30-Nov-2019-8:41:31:8615-hash128alphabets.bsabun // B差分
---1C //C差分のフォルダ
----1C-2019-Nov-30-8:53:31:8615.csabun //差分ファイル。C差分は次々ファイルにappendされていく。ハッシュ値は変わっていくのでつかない
----timestamps.txt //各差分のタイムスタンプとハッシュ値と何バイト目から始まるかが記録される。このファイルもappendされていく

ファイルは最新のものから差分を作られる場合ばかりではなく、昔のものを読み出す事もできる（それが差分生成してヒストリー全記録しておくメリットだ)
そしてそこから差分を新たに作ることもある。
多くの場合C差分ファイル内に埋もれたC差分を新たに新C差分として作り直すことになるだろう。
読みだしたのが1Cだった場合、2Cが新たに出来ることになるが、もともと2Cがすでに合った場合は2Cの2つめができることになる。
2つの2Cを区別するため、2C-2を作る。2C-2があった場合は2C-3、それもあったら2C-4・・・となる

初期値を記したjsonファイルはこんな感じ。
デフォルト値が変わるたびにjsonを書き換えると、ハッシュが一致しなくなり、必要もないのにスキーマ間の変換のための対応表を作る必要が発生するが、
そのくらい別にかまわないだろう。スキーマ間の変換は基本機能であり、特殊処理ではない。
ただ、一度でも差分生成に使用された初期jsonはバックアップがないと、jsonを書き換えられた時に差分ファイルが復元できないので、「単にjsonファイルをコピーしてバックアップする」必要があると思う。

{
  hogeNumber : 10,
  hogeString : "hoge",
  hogeBool : true,
  hogeObj : {
    hugaNumber : "30",

    //名前が?で終わるメンバはnull値を含むことが出来る。
    //プログラム側のメンバ名にはこの?は反映されず、型が変わるだけと想定される
    //JavaScriptで使う場合はメンバ名に?が入ると使いにくくなるだろうけれど・・・直接JSで初期値を読むユースケースがあるだろうか・・・？
    "hugaNumber?" : null,

    //配列はnumber配列、string配列、bool配列、それぞれ中身がnullableであるかの6通りとなる。最初に型を示し、その後初期値をいれる。
    numArray : [ "num-array", 0, 3, 10 ],
    nullableNumArray : [ "num?-array", 0, null, 10 ], //nullableの場合num?のようになる
    emptyNumArray : [ "num-array" ], //初期値が空配列のnum-array

    "numArray?" : [ "num-array?" ] //初期値がnullの場合、array?とする
    "numArray2?" : [ "num?-array?" ] //num?-array?もある。nullable整数配列であり初期値はnullである
	}

	hogeList : [
		"list", //listは配列とは違う。オブジェクトのコレクションを作るためにはlistを使う必要がある。
		["list-ID", "hogehoge"], //任意でlist-IDを与えることが出来る。list-IDは全データの中で一意である必要がある。
		{
			ID : "schema-dummy", //listの中身は全て同じ型のオブジェクトになっている必要がある。
			                     //そしてオブジェクトのデフォルト値を指定し、さらにリスト内で一意なIDも付加する。
			                     //IDがないと差分を生成する時に何がどう変わったのか不明になってしまい効率が悪い。
			                     //listのデフォルトオブジェクトは通常最初のものが使用されるが、初期値が空listだった場合や、
			                     //最初をデフォルトにしたくない場合も考えられるので、その場合IDをschema-dummyとしてデフォルトオブジェクトを記述する。
			                     //また、ここをschema-autoとすることで、IDは自動で連番が振られるようになる。
			                     //
			                     //listには新規オブジェクトが追加されたりするが、その場合はこのデフォルトオブジェクトとの差分を記録することになる。
			hogeNumber : 11,
			hogeString : "hoge"
		},
		{
			ID : "first",
			hogeNumber : 12,
			hogeString : "huga"
		},
		{
			ID : "second",
			//デフォルト値から変更がない場合は書かなくても良いんじゃないかと思う
		}
	],

	"prevName->currentName" : "schema-change-name", //メンバ名の変更をした場合、これを書いておくことで自動でメンバ名の対応表を作ってくれる。

	"member?" : 3,
	"member-undefined" : null, //スキーマ変換時にmemberが元のスキーマに定義されていなかった場合、初期値をnullにする。
	                           //プログラム側ではnullを発見したら、特定の計算式を使ってmemberに初期値を入れることになるだろう。
}

差分生成システムとは直接関係しないが、俺の考えるデータモデルでは、データの継承ができる。
{
	"ref-list-ID" : "hogehoge",
	"ref-ID" : "first",
	hogeNumber : 21 //オーバーライド
}

listIDとIDをRefとして指定することで、そのデータを参照し、さらに自分のところでオーバーライドできる。オーバーライドしても元データは変化しない。
Ref-list-IDはいちいち指定しなくても、このアイテムの親リストにRef-list-IDがあればそれを使う

hugaList : [
	"list",
	["list-ID", "hugahuga"],
	["ref-list-ID", "hogehoge"], //このリスト内のオブジェクトはrefする時にデフォルトでこのlistから探す
	{
		ID : "1",
		"ref-ID" : "first",
		hogeString : "huga",
		mishikibetsu : true,
		unknown_name : "緑の草",
	}
]

つまりあるリストのオブジェクトを継承するオブジェクトのリストというものが自然に作られる設計になっている。
たとえば風来のシレンのアイテムリストがある時に、それぞれのアイテムはそれがどういうものであるのか（薬草とかどうたぬきとか）を継承し、
さらに+1したり、名前が未識別だったりといった付加情報も追加する必要がある。そういうのを自然に表現できるといいと思う。
それをプログラム側に組み込みたいと思っているが、差分生成システムと全然関係がないので勝手に組み込んでいいものでもなさそうだ。
でも組み込むつもりだが。