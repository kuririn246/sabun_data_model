オブジェクトの場合「メンバがいくつあるか」は事前にわかっている。初期jsonファイルからのメンバの追加や削除は許されていない。
そしてメンバ名、順序も決まっている。といってもメンバ名でアルファベット順に並ぶだけだが。
メンバはオブジェクトと配列、リストを除くと、number,string,bool,nullable number, nullable bool, nullable stringの6通りであり、
その型も事前にわかっている。なのでこれらの情報は既知として差分バイナリには含まれない。

「どのメンバが変化したか」「変化した一つ一つのメンバに何バイト使われているか」「実際のバイト列はどうなっているか」が必要な情報である。
numberであっても、何バイト使っているかは実際の値によって変化する。できるだけ切り詰めるので、3バイト整数とかもある。
JavaScriptのnumberは64bit浮動小数であるが、jsonの文字列表現では浮動小数は表せない。
文字列との相互変換を想定するなら、本来10進数型にするべきだが、10進数で演算するのも大変なので、どうするべきか。
まあjsonは初期値にしか用いず、差分はバイナリなのでf64でいいんじゃないのという気がする。
途中必要になって文字列表現でjson化して確認したくなるかもしれないが、再度戻すことは想定しなくていいんじゃなかろうか。

まずどのメンバが変化したか、だが
0 変化無し
1 ビット列で変化を表現
いくつのメンバがあるかは分かっているため、変化したものは1、変化してないものは0で表す。
３つのうち真ん中のメンバだけ変化したなら010 最初に1がつくので1010
全部変化したなら111 最初に1をつけて1111となる

次の情報はそれぞれの変化したメンバの表現に何バイト使うかである。
「どのメンバが変化したか」と「変化したメンバそれぞれは何バイトもっているか」はビットで表現される。バイトで区切らず、ただビットの連続で表現して容量を節約する。
bool, nullable bool の場合はバイト数を設定する必要がないので、それぞれ1bit 2bitで値を設定する。
nullable値の場合は、nullable boolの場合も同じであるが、最初の1bitでnullかどうかを設定する。nullであれば中身は0バイトであり、bit表現だけで完結させる。
nullable boolの場合であってもnullであれば1bitで終わりで真理値は書かれない。

nullでない場合あるいはnullableでない場合はバイト数を設定する。
0 0バイトである。numberなら0, 文字列なら空文字列を表し、データ部には何もかかれない。
数値の場合
10 1バイトである。
110 2-4バイトまたは64bit浮動小数である。次の2bitでバイト数を指定
1110 5-8バイトである。次の2bitで指定。（JavaScriptのNumberはf64なので8バイト整数を正確に表現できないはずだが・・・まあいいや)

文字列の場合
10 1-16バイトである 次の4bitで指定
110 データ部の最初のバイトで文字列のバイト数を表し、その後実際の文字列バイトを続ける。これは255バイトまでの文字列に使える。
1110 最初の2バイトで文字列のバイト数を表す。32768バイトまでの文字列に使える。
11110 3-8バイトで表現される文字数の文字列を表すのに使う。この後の3bitで何バイトで表現される文字数の文字列かを表し、
データ部ではそのバイト数分使って、何文字の文字列かを最初に示し、その後実際の文字列を示す。文字列が1800京バイトくらいまでならこれで表現できる。

その後データ部が展開される。ここまでで指示された通りにデータがひたすら並ぶ。

というわけで、数値は8バイトまで、文字列は1800京文字くらいまで表現可能となっている。
数値の場合11110以降、文字列の場合111110以降は将来のために予約されている。

配列の場合も、型はついていて、それぞれの値がどう表現されるかはオブジェクトのときと同じ。

まず、何箇所で並び順の変化がおこっているかを最初のバイトで示す
0 次の7bitで何箇所に変化が起きたかを示す。0-127個の変化を表せる。
1 次の7bitで変化が起きた数が何バイトで表現されるかを表す。実際は8バイトも変化があったらまともにファイルに収まるわけないのだが、0-127バイトまで表せる

1の場合次のバイト列で何箇所かを示す

配列の変化は、「インデックスx から、y個の連続したアイテムをここにコピーする」と「ここに新規にアイテムを作る」の２つの命令をいくつも書いて表現する。
同じ並びがあればそのまま使えるし、逆引きディクショナリを作れば調べるのも難しくない。

この2種類の打ちどちらであるかをビット列で表現する。ビットがいくつになるかは最初で分かっている。
コピーの場合はさらに情報が必要である。
インデックスxと連続数yはこのように示される。
1 次の7bitで数値を表す 0-64
01 次の14bitで数値を表す
001 次の21bitでー
0001 次の28bitでー
00001 35
000001 42
0000001 49
仕様上49bit までとしておく 56以降は将来のために予約しておく。この数値表現をインデックス値と呼ぶ
この数値2つの組によりxからy個をコピーが記述される

ここまでで配列のいくつのアイテムが含まれるかは、変化情報があれば見れば分かるし、変化情報がない場合は過去のデータを参照すれば分かる。
同IDのアイテムに変化がある場合（新規アイテムの場合はデフォルトから変化がある場合）、
1 オブジェクトのときと同じようにビット列で変化を表現する
2 変化したオブジェクトのインデックス番号の連続で表現する
この2つのうちどちらかを使って、できればデータ量が小さくなるように表現する（別に強制ではないので仕様上はどちらを使っても良い）。
0 変化無し
01 ビット列で変化を表現。続くビット列で書く。
001 インデックス番号の連続で表現
0011 インデックス番号の連続の数は続く4bitに収まる。続く4bitに記述する
0010 4bitにおさまらないので次のバイトにインデックス数で書く。
0001　将来のために予約

で、インデックス数の連続の場合、この後インデックス数を連続して書いていく。

これによって変化したインデックスが特定できたら、あとはオブジェクトのときと同じように変化のデータを記述していく。

オブジェクトの中にあるオブジェクトの差分は、再帰関数を適用することで作る。
リストでは同一性は配列とは違ってIDを用いて判定する。リスト内のオブジェクトの差分はオブジェクトの差分と同じ仕様でデータ化する。リストの順番の変化は配列と同じ仕様でデータ化する。

これで全てbyte表現することが可能になったはずだ。

