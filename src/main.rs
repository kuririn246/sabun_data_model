fn main() {

    fn create_seq(a : i32, d : i32, n : i32) -> Vec<i32>{
        let mut v : Vec<i32> = vec![];
        for x in 0..n{
            v.push(a + d * x);
        }
        v
    }

//    for n in 1..100 {
//        let n = n as f64;
//        let a = 40.0;
//        let d = 0.000000000000001;
//        let end = a + d * (n - 1.0);
//        let end_next = end + d;
//        let s = n * (a + end) / 2.0;
//        let s_next = s + end_next;
//        let b_sabun_base = 50.0;
//        //C差分の変化したメンバのうち、B差分でも変化していたもの。この部分はB差分リベース時にB差分の容量を増やさない
//        let b_sabun_ritu = 0.8;
//        let b_sabun = b_sabun_base + end * (1.0 - b_sabun_ritu);
//        let b_sabun_next = b_sabun_base + end_next * (1.0 - b_sabun_ritu);
//
//        //println!("B+a={} d/2n(n+1)={}", b_sabun + a, (d as f64) / (2.0 * n * (n + 1.0)) );
////        println!("{}, (s+b')/(n+1)={} (s_next + b'') / (n+2)={}", n,
////                 (s + b_sabun + end * (1.0 - b_sabun_ritu)) / (n + 1.0),
////                 (s_next + b_sabun + (end + d) * (1.0 - b_sabun_ritu)) / (n+2.0) );
//
//        println!("{}, s={} s_next={}", n,
//                 s, s_next);
//
//        let avg = (s + b_sabun) / (n + 1.0);
//        let avg_next = (s_next + b_sabun) / (n + 2.0);
//
//        //b差分の大きさが変わるものとしても変わらないものとしても結果がたいして変わらないので、変わらないものとして計算してしまってよいのではないか。
//        println!("{}, (s+b)/(n+1)={} (s_next + b) / (n+2)={}", n, avg, avg_next);
//
//        if avg < avg_next {
//            break;
//        }
//    }

    let moto = 10.0;
    let shin = 5.0;
    let b_sabun = 50.0;
    for n in 1..100{
        let mut turn = n as f64;
        let current = (b_sabun * 2.0 + shin * turn) / (turn + 2.0);
        let next = ((b_sabun * 2.0 + shin * (turn + 1.0)) + moto) / (turn + 4.0);
        let big = if current < next{ "big" } else { "small" };
        println!("{} {} {} {}", big, turn, current, next);
    }




        //つまり、C差分の合計量と、次のC差分の予想される大きさ（直近のサイズの変化率を次にも当てはめて無理やり求める)
        //それに変化しないものと仮定したB差分の大きさから、現在リベースしたときの平均サイズと、次にリベースしたときの平均サイズを求め、
        //平均サイズが次だと大きくなってしまう場合はリベースする。

        //変化率は1発目だと求められない。この場合、C差分がB差分より大きい時は、無条件でリベースする。
        //(C差分+B差分)/2 < (C差分 + C差分 + B差分)/3 のどちらが大きいか求める
        //つまり (1/2-1/3)B差分< (2/3 - 1/2)C差分
        //1/6B差分 < 1/6C差分 よって B差分 < C差分 の時リベースするのが良い

        //(a + b) / n より (a + d + b) / (n+1)が大きくなる条件は
//        (a + b) / n より (a + d + b) / (n+1)が大きくなる条件は
//        (a + b) / n - (a + d + b) / (n+1) < 0
//        (a + b)(n+1) - (a + d + b)n < 0
//        (a+b) + n((a+b)-(a+d+b)) < 0
//        a+b - nd < 0
//        a+b < nd
        //dは正であることが期待されていて、ndはnの増加とともに増えていく。
        //bはb差分の定数だ。aは今までの差分の総和になっている。記号を直して
        //s+b < ne
        //b < ne - s
        //n(a1+dn) - (a1 + a1 + dn)n/2
        //an + dn^2 - (an + dn^2/2)
        //b < dn^2/2
        //2b < dn^2
        //2b/d < n^2

        //この計算式の問題点は、dが正でない限り条件を満たせないこと。
        //B差分の大きさに近いC差分があるものの、増加率が非常に小さい場合、リベースされないはずである。
        //しかし、最初のC差分で巨大な差分が発生し、その後増えなかった場合、
        //すぐにリベースすればずっと小さい差分で済んだかもしれないのに、リベースする決断ができない。

        //これは、リベース後に同じことが起きる、つまりすぐに巨大な差分が発生すると仮定すると、リベースしてもあまり得がないので
        //理にかなった動きではある。しかしそうではなかった場合、リベース後は小さな差分しか発生しないのだとすれば、
        //巨大なC差分の連続は全て無駄ということになる。

        //リベース後に発生するC差分の量は前回C差分との差分生成により構築可能である。
        //その計算は実際のところ通常使われないのだが、やる価値はありそうな気がする。現実的に気になるほどの時間がかかる処理にはならない気がするし。

        //実際のところ増加率のことは考えなくてよいのではないか？
        //増加率だとたまたま小さい変化しかなくD差分が極端に小さかったときに極端な結果が生じると思う。
        //なので、ずっとトラッキングし続けたC差分の平均増加量がずっと続くものと仮定しよう

        //ただしD差分のサイズのC差分を作るには一つ前のC差分を遡ってB差分にする必要がある
        //さらに、「たまたまセーブが短い間隔で行われ、D差分が小さかっただけ」という状況にたやすく反応してしまう

        //C差分のうち変化のない部分が十分に大きくなったらB差分に移す、というのが基本方針であるが、
        //変化のない部分をどう定義しどう検出するかが大問題である。
        //ここが変化していて、ここは変化していない、ということをトラッキングし続けるのは難しいし、そのためにデータ量が大きくなれば本末転倒である。
        //たとえば、B差分がリベースされてからのC差分のうち3/4のところにあるC差分と、現在のC差分を調べて、
        //共通の値を持っている部分は変化してないと考え、そこをB差分に移すことで差分の容量が節約可能になるはずである。

        //節約可能な容量*リベースからの差分生成回数＜ベースのサイズ
        //を満たすとき、リベースすることで容量の節約が可能になると予想できる。が、これが長い目で見たデータ量を最小にする戦略とは思えない。
        //ベースを作るコストより少ししか節約できていないため、ほとんど得がないはずである。

        //たとえば10回C差分を生成して、10のうち5が共通部分でリベースにより節約できるとしよう
        //ベースのサイズは50である。今リベースをするときの期待される節約は、
        //リベース語に全く同じ増加率でデータが増加し続け、さらにB差分のサイズはいつリベースしても変わらないとするとき、
       //今リベースしたときと、次でリベースしたときで比較する。
    //10ターンでリベースするとすると、B差分50 + 新C差分5 * 10 + B差分50 / 12 =  11.4285...
    //11ターンでリベースだと、 旧C差分10 + B差分50 + 新C差分5 * 11 + B差分50 / 14 =  10.9375
    //次でリベースしたほうが平均サイズが小さいので次でやろう、という判断ができる。
    //これを続けていくと、35ターンで正負が逆転する。

    //数式で逆転条件をみていく
    /// 2B + Cn / (n + 2)
    /// C' + 2B + C(n+1) / (n + 4)
    /// (2B + Cn)(n + 4) < (C' + 2B + C(n + 1)) (n + 2)
    /// 2Bn + Cn'2 + 8B + 4Cn < C'n + 2Bn + Cn^2 + Cn + 2C' + 4B + 2Cn + 2C
    ///   4B + Cn < C'n  + 2C'   + 2C
    ///   4B  < n(C' - C) + 2(C' + C)
    ///   4B - 2(C' + C) < n(C' - C)

    // つまりC が B なみに大きければ、左辺が負になるのでリベース、
    // 左辺はほぼ定数であるが、C'が増えるほど条件はゆるくなる
    // 右辺は C' - C は正になるはずなので n が増えれば単調増加するので
    // そのうち逆転することが証明された

}
