fn main() {

    let moto = 10.0;
    let shin = 5.0;
    let b_sabun = 50.0;
    for n in 1..100{
        let mut turn = n as f64;
        let current = (b_sabun * 2.0 + shin * turn) / (turn + 2.0);
        let next = ((b_sabun * 2.0 + shin * (turn + 1.0)) + moto) / (turn + 4.0);
        let big = if current < next{ "big" } else { "small" };
        println!("{} {} {} {}", big, turn, current, next);
    }





        //C差分のうち変化のない部分が十分に大きくなったらB差分に移す、というのが基本方針であるが、
        //変化のない部分をどう定義しどう検出するかが大問題である。
        //ここが変化していて、ここは変化していない、ということをトラッキングし続けるのは難しいし、そのためにデータ量が大きくなれば本末転倒である。
        //たとえば、B差分がリベースされてからのC差分がn個あったとして、そのうち3/4n個目のところにあるC差分と、現在のC差分を調べて、
        //共通の値を持っている部分は変化してないと考え、そこをB差分に移すことで差分の容量が節約可能になるはずである。

        //節約可能な容量*リベースからの差分生成回数＜ベースのサイズ
        //を満たすとき、リベースすることで容量の節約が可能になると予想できる。が、これが長い目で見たデータ量を最小にする戦略とは思えない。
        //ベースを作るコストより少ししか節約できていないため、ほとんど得がないはずである。

        //たとえば10回C差分を生成して、10のうち5が共通部分でリベースにより節約できるとしよう
        //ベースのサイズは50である。今リベースをするときの期待される節約は、
        //リベース語に全く同じ増加率でデータが増加し続け、さらにB差分のサイズはいつリベースしても変わらないとするとき、
       //今リベースしたときと、次でリベースしたときで比較する。
    //10ターンでリベースするとすると、B差分50 + 新C差分5 * 10 + B差分50 / 12 =  11.4285...
    //11ターンでリベースだと、 旧C差分10 + B差分50 + 新C差分5 * 11 + B差分50 / 14 =  10.9375
    //次でリベースしたほうが平均サイズが小さいので次でやろう、という判断ができる。
    //これを続けていくと、35ターンで正負が逆転する。

    //数式で逆転条件をみていく
    /// 2B + Cn / (n + 2)
    /// C' + 2B + C(n+1) / (n + 4)
    /// (2B + Cn)(n + 4) < (C' + 2B + C(n + 1)) (n + 2)
    /// 2Bn + Cn^2 + 8B + 4Cn < C'n + 2Bn + Cn^2 + Cn + 2C' + 4B + 2Cn + 2C
    ///   4B + Cn < C'n  + 2C'   + 2C
    ///   4B  < n(C' - C) + 2(C' + C)
    ///   4B - 2(C' + C) < n(C' - C)

    // つまりC が B なみに大きければ、左辺が負になるのでリベース、
    // 左辺はほぼ定数であるが、C'が増えるほど条件はゆるくなる
    // 右辺は C' - C は正になるはずなので n が増えれば単調増加するので
    // そのうち逆転することが証明された

}
