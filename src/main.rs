fn main() {

    fn create_seq(a : i32, d : i32, n : i32) -> Vec<i32>{
        let mut v : Vec<i32> = vec![];
        for x in 0..n{
            v.push(a + d * x);
        }
        v
    }

    for n in 1..100 {
        let n = n as f64;
        let a = 40.0;
        let d = 0.000000000000001;
        let end = a + d * (n - 1.0);
        let end_next = end + d;
        let s = n * (a + end) / 2.0;
        let s_next = s + end_next;
        let b_sabun_base = 50.0;
        //C差分の変化したメンバのうち、B差分でも変化していたもの。この部分はB差分リベース時にB差分の容量を増やさない
        let b_sabun_ritu = 0.8;
        let b_sabun = b_sabun_base + end * (1.0 - b_sabun_ritu);
        let b_sabun_next = b_sabun_base + end_next * (1.0 - b_sabun_ritu);

        //println!("B+a={} d/2n(n+1)={}", b_sabun + a, (d as f64) / (2.0 * n * (n + 1.0)) );
//        println!("{}, (s+b')/(n+1)={} (s_next + b'') / (n+2)={}", n,
//                 (s + b_sabun + end * (1.0 - b_sabun_ritu)) / (n + 1.0),
//                 (s_next + b_sabun + (end + d) * (1.0 - b_sabun_ritu)) / (n+2.0) );

        println!("{}, s={} s_next={}", n,
                 s,s_next);

        let avg = (s + b_sabun ) / (n + 1.0);
        let avg_next = (s_next + b_sabun) / (n+2.0);

        //b差分の大きさが変わるものとしても変わらないものとしても結果がたいして変わらないので、変わらないものとして計算してしまってよいのではないか。
        println!("{}, (s+b)/(n+1)={} (s_next + b) / (n+2)={}", n, avg, avg_next);

        if avg < avg_next{
            break;
        }

        //つまり、C差分の合計量と、次のC差分の予想される大きさ（直近のサイズの変化率を次にも当てはめて無理やり求める)
        //それに変化しないものと仮定したB差分の大きさから、現在リベースしたときの平均サイズと、次にリベースしたときの平均サイズを求め、
        //平均サイズが次だと大きくなってしまう場合はリベースする。

        //変化率は1発目だと求められない。この場合、C差分がB差分より大きい時は、無条件でリベースする。
        //(C差分+B差分)/2 < (C差分 + C差分 + B差分)/3 のどちらが大きいか求める
        //つまり (1/2-1/3)B差分< (2/3 - 1/2)C差分
        //1/6B差分 < 1/6C差分 よって B差分 < C差分 の時リベースするのが良い

        //(a + b) / n より (a + d + b) / (n+1)が大きくなる条件は
//        (a + b) / n より (a + d + b) / (n+1)が大きくなる条件は
//        (a + b) / n - (a + d + b) / (n+1) < 0
//        (a + b)(n+1) - (a + d + b)n < 0
//        (a+b) + n((a+b)-(a+d+b)) < 0
//        a+b - nd < 0
//        a+b < nd
        //dは正であることが期待されていて、ndはnの増加とともに増えていく。
        //bはb差分の定数だ。aは今までの差分の総和になっている。記号を直して
        //s+b < ne
        //b < ne - s
        //n(a1+dn) - (a1 + a1 + dn)n/2
        //an + dn^2 - (an + dn^2/2)
        //b < dn^2/2
        //2b < dn^2
        //2b/d < n^2

        //この計算式の問題点は、dが正でない限り条件を満たせないこと。
        //B差分の大きさに近いC差分があるものの、増加率が非常に小さい場合、リベースされないはずである。
        //しかし、最初のC差分で巨大な差分が発生し、その後増えなかった場合、
        //すぐにリベースすればずっと小さい差分で済んだかもしれないのに、リベースする決断ができない。

        //これは、リベース後に同じことが起きる、つまりすぐに巨大な差分が発生すると仮定すると、リベースしてもあまり得がないので
        //理にかなった動きではある。しかしそうではなかった場合、リベース後は小さな差分しか発生しないのだとすれば、
        //巨大なC差分の連続は全て無駄ということになる。

        //リベース後に発生するC差分の量は前回C差分との差分生成により構築可能である。
        //その計算は実際のところ通常使われないのだが、やる価値はありそうな気がする。現実的に気になるほどの時間がかかる処理にはならない気がするし。
        //増加率は
    }
}
